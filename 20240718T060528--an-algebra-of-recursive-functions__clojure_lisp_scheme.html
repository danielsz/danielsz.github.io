<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-07-27 Sat 12:23 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>An algebra of recursive functions</title>
<meta name="author" content="Daniel Szmulewicz" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="css/grid.css">
<link rel="stylesheet" type="text/css" href="css/post.css">
<link rel="stylesheet" type="text/css" href="assets/fonts/charter/webfonts/stylesheet.css">
<link rel="stylesheet" type="text/css" href="css/typography.css">
<link href="https://fonts.googleapis.com/css?family=Merriweather+Sans|Roboto+Condensed|Source+Serif+Pro|Inconsolata" rel="stylesheet">
<script src="js/grid.js"></script>
<script src="js/fathom.js"></script>
<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="index.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="content">
<header>
<h1 class="title">An algebra of recursive functions</h1>
</header><p>
Recursion is an idea often associated with infinity, a process that
repeats ad aeternam. It is perhaps surprising, then, that the origin
story of mathematical recursion is grounded in finitism, the rejection
of all things infinite.
</p>

<blockquote>
<p>
In 1923, Skolem developed a theory of recursive functions as a means
of avoiding the so-called paradoxes of the infinite in his paper
Begr√ºndung der element√§ren Arithmetik durch die rekurrierende
Denkweise ohne Anwendung scheinbarer Ver√§nderlichen mit unendlichem
Ausdehnugsbereich<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup> (Skolem, T., 1923)
</p>
</blockquote>

<p>
Primitive recursion was actually originally introduced by Dedekind in
1888, and proposed as a basis for arithmetic by Skolem in 1923. There
is no lack of mathematical resources describing the recursive
functions, but in this post we are going to try and build an
<i>intuition</i> for the primitive recursive functions.
</p>

<blockquote>
<p>
We believe that programming languages are the best way to convey the
concept of recursion. They share with mathematics the ability to give
a formal meaning to a set of symbols. But unlike mathematics,
programming languages can be directly experienced-you can take the
programs in this book, observe their behavior, modify them , and
experience the effect of these modifications. (Friedman, Daniel P. and Felleisen, Matthias, 1996)
</p>
</blockquote>

<p>
Daniel Friedman and Matthias Felleisen wrote <i>The Little Schemer</i> and
through a Socratic dialogue taught recursion in Scheme, arguing that
the requirements to be a successful learner was not analytical
reasoning but pattern recognition.
</p>

<p>
To understand the practicalities of recursion in Lisp, <i>The Little
Schemer</i> is indeed a fantastic reference. In contrast, to understand
the theoretical foundation of Lisp, the traditional mathematical
treatment of he topic cannot be avoided. Despite all of this, I
believe the use of computer programs can be beneficial here as well.
</p>

<p>
By faithfully translating the rules of primitive recursion into a
computer program, we breathe life into it (as it were). A computer
program is something concrete: runnable, repl-able, inspectable,
steppable, etc. This is the constructivist approach: learning means
<i>constructing</i> an understanding through experiences and interaction.
</p>

<p>
The goal of our exercise is to understand the framework of primitive
recursion in the terms within which it appeared in the
literature. This is purely an academic pursuit. The motivation for
this endeavor lies in a quest to tackle the <i>big ideas</i> at the
crossroads of Logic, Mathematics and Computer Science, such as:
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Foundations_of_mathematics#Foundational_crisis"><i>Grundlagenkrise der Mathematik</i></a></li>
<li><a href="https://en.wikipedia.org/wiki/Finitism">Finitism</a></li>
<li>G√∂del's <a href="https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems">arithmetization of syntax</a></li>
<li><a href="https://en.wikipedia.org/wiki/Computability_theory">Recursion theory</a></li>
<li><a href="https://en.wikipedia.org/wiki/McCarthy_Formalism">The origins of Lisp</a></li>
</ul>

<p>
The goal is not only to show how primitive recursion works, but also
to convey its beauty: with how little we can build so much.
Primitive recursion is not complicated, but surprising. Indeed, it
takes only three initial functions closed under two operations to
produce all of the familiar functions on the natural numbers.
</p>

<blockquote>
<p>
&#x2026; most computable functions that are studied in number theory (and
more generally in mathematics) are primitive recursive. For example,
addition and division, the factorial and exponential function, and the
function which returns the nth prime are all primitive
recursive. (Brainerd, Walter S. and Landweber, Lawrence H., 1974)
</p>
</blockquote>

<p>
It might be interesting to start with a quick glance at the
traditional presentation of the topic. Wikipedia has a decent <a href="https://en.wikipedia.org/wiki/Primitive_recursive_function">entry</a>,
or have a look at <a href="https://plato.stanford.edu/entries/recursive-functions/">Stanford Encyclopedia of Philosophy</a>. Look at the
formulas describing primitive recursion, even if they are opaque. At
the end of our exercise, we will have a basis of comparison. We might
know the answer to the question whether or not a Lisp expos√© improve
on the learning experience?
</p>

<p>
That being said, we are going to stick close to some conventions found
in the traditional treatment the of topic, up to the capitalized
one-letter naming scheme for functions. This will makes it easy for
learners to switch back and forth between the code and the
formalism. Please do not hesitate to replace the one-letter function
names with something more palatable if that makes things easier for
you. And remember that you can trace the execution of the functions in
the REPL.
</p>

<p>
Our first rule is the Zero rule.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span><span style="color: #b6a0ff;">def</span> <span style="color: #00d3d0;">Z</span> #<span style="color: #2fafff;">(</span><span style="color: #b6a0ff;">fn</span> <span style="color: #d8af7a;">[</span>&amp; _<span style="color: #d8af7a;">]</span> 0<span style="color: #2fafff;">)</span><span style="color: #ffa00f;">)</span>
</pre>
</div>

<p>
This function returns a function that takes any number of arguments
and always returns zero. 
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">[</span><span style="color: #2fafff;">(</span><span style="color: #d8af7a;">(</span>Z<span style="color: #d8af7a;">)</span><span style="color: #2fafff;">)</span> <span style="color: #2fafff;">(</span><span style="color: #d8af7a;">(</span>Z<span style="color: #d8af7a;">)</span> 5<span style="color: #2fafff;">)</span> <span style="color: #2fafff;">(</span><span style="color: #d8af7a;">(</span>Z<span style="color: #d8af7a;">)</span> 1 2 3<span style="color: #2fafff;">)</span><span style="color: #ffa00f;">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">[0 0 0]
</pre>
</div>

<p>
Our second basic function is the <a href="https://en.wikipedia.org/wiki/Successor_function">successor function</a>. Yes, <a href="https://en.wikipedia.org/wiki/Successor_function">that one</a>
from <a href="https://en.wikipedia.org/wiki/Peano_axioms">number theory</a>. It isn't more complicated as our zero function: it
increments a number by one.
</p>

<p>
It is identical to <code>inc</code> in Clojure, so we will just alias it.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span><span style="color: #b6a0ff;">def</span> <span style="color: #00d3d0;">S</span> inc<span style="color: #ffa00f;">)</span>
</pre>
</div>

<p>
Our last basic function is trickier to explain because its purpose may
not be immediately apparent. It is called the projection function and
it plucks an element from a sequence. Its role is auxiliary, but
nonetheless crucial. It is used to configure primitive recursion by
rearranging function arguments. We will see it in action soon.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">P</span> <span style="color: #2fafff;">[</span>i<span style="color: #2fafff;">]</span>
  <span style="color: #2fafff;">(</span><span style="color: #b6a0ff;">fn</span> <span style="color: #d8af7a;">[</span>&amp; args<span style="color: #d8af7a;">]</span> <span style="color: #d8af7a;">(</span>nth args <span style="color: #79a8ff;">(</span>dec i<span style="color: #79a8ff;">)</span><span style="color: #d8af7a;">)</span><span style="color: #2fafff;">)</span><span style="color: #ffa00f;">)</span>
</pre>
</div>

<p>
<i>Note:</i> The projection function is not zero-based, but the ArraySeq containing
the arguments is, so we make the decrement adjustment.
</p>

<p>
Our first operation is composition. We will call it capital
C. Remember, the initial or basic functions operate on natural
numbers, the operations act on those initial functions.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">C</span> <span style="color: #2fafff;">[</span>f &amp; gs<span style="color: #2fafff;">]</span>
  <span style="color: #2fafff;">(</span><span style="color: #b6a0ff;">fn</span> <span style="color: #d8af7a;">[</span>&amp; xs<span style="color: #d8af7a;">]</span> <span style="color: #d8af7a;">(</span>apply f <span style="color: #79a8ff;">(</span>map #<span style="color: #cabf00;">(</span>apply <span style="color: #00d3d0;">%</span> xs<span style="color: #cabf00;">)</span> gs<span style="color: #79a8ff;">)</span><span style="color: #d8af7a;">)</span><span style="color: #2fafff;">)</span><span style="color: #ffa00f;">)</span>
</pre>
</div>

<p>
Composition takes a function ùëì and any number of functions ùëî, and
returns a function that receives any number of arguments and applies f
to the result of applying functions ùëî on those arguments.
</p>

<p>
In some textbooks it is called the substitution operator; it is used
for substituting constants, permuting variable and composing functions.
</p>

<p>
The following usage example may help.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span><span style="color: #2fafff;">(</span>C S <span style="color: #d8af7a;">(</span>P 1<span style="color: #d8af7a;">)</span><span style="color: #2fafff;">)</span> 5 11<span style="color: #ffa00f;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">6
</pre>
</div>

<p>
Contrast with:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span><span style="color: #2fafff;">(</span>C S <span style="color: #d8af7a;">(</span>P 2<span style="color: #d8af7a;">)</span><span style="color: #2fafff;">)</span> 5 11<span style="color: #ffa00f;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">12
</pre>
</div>

<p>
Finally, the recursion operation.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">R</span> <span style="color: #2fafff;">[</span>n &amp; xs<span style="color: #2fafff;">]</span>
  <span style="color: #2fafff;">(</span><span style="color: #b6a0ff;">fn</span> <span style="color: #d8af7a;">[</span>f g<span style="color: #d8af7a;">]</span>
    <span style="color: #d8af7a;">(</span><span style="color: #b6a0ff;">loop</span> <span style="color: #79a8ff;">[</span>i 1
           j 0
           acc <span style="color: #cabf00;">(</span>apply f xs<span style="color: #cabf00;">)</span><span style="color: #79a8ff;">]</span>
      <span style="color: #79a8ff;">(</span><span style="color: #b6a0ff;">if</span> <span style="color: #cabf00;">(</span>&lt;= i n<span style="color: #cabf00;">)</span>
        <span style="color: #cabf00;">(</span><span style="color: #b6a0ff;">recur</span> <span style="color: #4ae2f0;">(</span>inc i<span style="color: #4ae2f0;">)</span> <span style="color: #4ae2f0;">(</span>inc j<span style="color: #4ae2f0;">)</span> <span style="color: #4ae2f0;">(</span>apply <span style="color: #d2b580;">(</span>partial g j acc<span style="color: #d2b580;">)</span> xs<span style="color: #4ae2f0;">)</span><span style="color: #cabf00;">)</span>
        acc<span style="color: #79a8ff;">)</span><span style="color: #d8af7a;">)</span><span style="color: #2fafff;">)</span><span style="color: #ffa00f;">)</span>
</pre>
</div>

<p>
Function ùëì is used for the initial computation only. After such
initialization, function ùëî is proceeding by applying its rules,
whatever they may be, on the previous computed value. Hence, the
recursion.
</p>

<p>
The most important thing to notice here is that the recursion is
bounded. In other words, we know in advance the number of times the
procedure will repeat itself, namely, ùêß number of times. Primitive
recursion is always bounded, it is guaranteed to halt.
</p>

<p>
Now that we have the pieces in place we can start build our algebra of
primitive recursive functions.  Have you noticed that conspicuously
absent from our framework so far are the natural numbers themselves?
Following the principle of induction, we can generate the
natural numbers with zero and the successor function. 
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">k</span> <span style="color: #2fafff;">[</span>n<span style="color: #2fafff;">]</span>
  <span style="color: #2fafff;">(</span><span style="color: #b6a0ff;">fn</span> <span style="color: #d8af7a;">[</span>&amp; _<span style="color: #d8af7a;">]</span>
    <span style="color: #d8af7a;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #79a8ff;">[</span>f <span style="color: #cabf00;">(</span>Z<span style="color: #cabf00;">)</span>
          g <span style="color: #cabf00;">(</span>C S <span style="color: #4ae2f0;">(</span>P 1<span style="color: #4ae2f0;">)</span><span style="color: #cabf00;">)</span><span style="color: #79a8ff;">]</span>
      <span style="color: #79a8ff;">(</span><span style="color: #cabf00;">(</span>R n<span style="color: #cabf00;">)</span> f g<span style="color: #79a8ff;">)</span><span style="color: #d8af7a;">)</span><span style="color: #2fafff;">)</span><span style="color: #ffa00f;">)</span>
</pre>
</div>

<p>
Usage:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">[</span><span style="color: #2fafff;">(</span><span style="color: #d8af7a;">(</span>k 5<span style="color: #d8af7a;">)</span> 5<span style="color: #2fafff;">)</span> <span style="color: #2fafff;">(</span><span style="color: #d8af7a;">(</span>k 5<span style="color: #d8af7a;">)</span> 6<span style="color: #2fafff;">)</span> <span style="color: #2fafff;">(</span><span style="color: #d8af7a;">(</span>k 5<span style="color: #d8af7a;">)</span> 7<span style="color: #2fafff;">)</span><span style="color: #ffa00f;">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">[5 5 5]
</pre>
</div>

<p>
No matter what the input is, the function returns the number of times
we applied the successor function starting from zero. 
</p>

<p>
Addition is achieved by applying the successor function ùê± times on
ùê≤ + 1.  
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">add</span> <span style="color: #2fafff;">[</span>x y<span style="color: #2fafff;">]</span>
  <span style="color: #2fafff;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #d8af7a;">[</span>f <span style="color: #79a8ff;">(</span>P 1<span style="color: #79a8ff;">)</span>
        g <span style="color: #79a8ff;">(</span>C S <span style="color: #cabf00;">(</span>P 2<span style="color: #cabf00;">)</span><span style="color: #79a8ff;">)</span><span style="color: #d8af7a;">]</span>
    <span style="color: #d8af7a;">(</span><span style="color: #79a8ff;">(</span>R x y<span style="color: #79a8ff;">)</span> f g<span style="color: #d8af7a;">)</span><span style="color: #2fafff;">)</span><span style="color: #ffa00f;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span>add 4 5<span style="color: #ffa00f;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">9
</pre>
</div>

<p>
We can leverage addition to define multiplication.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">mul</span> <span style="color: #2fafff;">[</span>x y<span style="color: #2fafff;">]</span>
  <span style="color: #2fafff;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #d8af7a;">[</span>f <span style="color: #79a8ff;">(</span>Z<span style="color: #79a8ff;">)</span>
        g <span style="color: #79a8ff;">(</span>C add <span style="color: #cabf00;">(</span>P 2<span style="color: #cabf00;">)</span> <span style="color: #cabf00;">(</span>P 3<span style="color: #cabf00;">)</span><span style="color: #79a8ff;">)</span><span style="color: #d8af7a;">]</span>
    <span style="color: #d8af7a;">(</span><span style="color: #79a8ff;">(</span>R x y<span style="color: #79a8ff;">)</span> f g<span style="color: #d8af7a;">)</span><span style="color: #2fafff;">)</span><span style="color: #ffa00f;">)</span>
</pre>
</div>

<p>
Usage:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span>mul 6 7<span style="color: #ffa00f;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">42
</pre>
</div>

<p>
By definition, any function composed from the basic function and the
operations is primitive recursive. Likewise, any derivation, like
addition or multiplication, is also primitive recursive. This is how
we develop an algebra of primitive recursive functions.
</p>

<p>
Factorial leverages multiplication, predictably. As does exponentiation.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">fac</span> <span style="color: #2fafff;">[</span>n<span style="color: #2fafff;">]</span>
  <span style="color: #2fafff;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #d8af7a;">[</span>f <span style="color: #79a8ff;">(</span>k 1<span style="color: #79a8ff;">)</span>
        g <span style="color: #79a8ff;">(</span>C mul <span style="color: #cabf00;">(</span>P 2<span style="color: #cabf00;">)</span> <span style="color: #cabf00;">(</span>C S <span style="color: #4ae2f0;">(</span>P 1<span style="color: #4ae2f0;">)</span><span style="color: #cabf00;">)</span><span style="color: #79a8ff;">)</span><span style="color: #d8af7a;">]</span>
    <span style="color: #d8af7a;">(</span><span style="color: #79a8ff;">(</span>R n<span style="color: #79a8ff;">)</span> f g<span style="color: #d8af7a;">)</span><span style="color: #2fafff;">)</span><span style="color: #ffa00f;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">[</span><span style="color: #2fafff;">(</span>fac 3<span style="color: #2fafff;">)</span> <span style="color: #2fafff;">(</span>fac 4<span style="color: #2fafff;">)</span> <span style="color: #2fafff;">(</span>fac 5<span style="color: #2fafff;">)</span><span style="color: #ffa00f;">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">[6 24 120]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">pow</span> <span style="color: #2fafff;">[</span>x y<span style="color: #2fafff;">]</span>
  <span style="color: #2fafff;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #d8af7a;">[</span>f <span style="color: #79a8ff;">(</span>k 1<span style="color: #79a8ff;">)</span>
        g <span style="color: #79a8ff;">(</span>C mul <span style="color: #cabf00;">(</span>P 2<span style="color: #cabf00;">)</span> <span style="color: #cabf00;">(</span>P 3<span style="color: #cabf00;">)</span><span style="color: #79a8ff;">)</span><span style="color: #d8af7a;">]</span>
    <span style="color: #d8af7a;">(</span><span style="color: #79a8ff;">(</span>R y x<span style="color: #79a8ff;">)</span> f g<span style="color: #d8af7a;">)</span><span style="color: #2fafff;">)</span><span style="color: #ffa00f;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">[</span><span style="color: #2fafff;">(</span>pow 3 4<span style="color: #2fafff;">)</span> <span style="color: #2fafff;">(</span>pow 4 3<span style="color: #2fafff;">)</span> <span style="color: #2fafff;">(</span>pow 4 5<span style="color: #2fafff;">)</span> <span style="color: #2fafff;">(</span>pow 5 4<span style="color: #2fafff;">)</span><span style="color: #ffa00f;">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">[81 64 1024 625]
</pre>
</div>

<p>
By interpreting 1 and 0 as boolean values, we can define predicates,
like <code>zero?</code>.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">z</span> <span style="color: #2fafff;">[</span>n<span style="color: #2fafff;">]</span>
  <span style="color: #2fafff;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #d8af7a;">[</span>f <span style="color: #79a8ff;">(</span>k 1<span style="color: #79a8ff;">)</span>
        g <span style="color: #79a8ff;">(</span>Z<span style="color: #79a8ff;">)</span><span style="color: #d8af7a;">]</span>
    <span style="color: #d8af7a;">(</span><span style="color: #79a8ff;">(</span>R n<span style="color: #79a8ff;">)</span> f g<span style="color: #d8af7a;">)</span><span style="color: #2fafff;">)</span><span style="color: #ffa00f;">)</span>
</pre>
</div>

<p>
Usage:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">[</span><span style="color: #2fafff;">(</span>z 0<span style="color: #2fafff;">)</span> <span style="color: #2fafff;">(</span>z 1<span style="color: #2fafff;">)</span> <span style="color: #2fafff;">(</span>z 2<span style="color: #2fafff;">)</span><span style="color: #ffa00f;">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">[1 0 0]
</pre>
</div>

<p>
And now we can define a IF-THEN-ELSE function.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">ite</span> <span style="color: #2fafff;">[</span>x y z<span style="color: #2fafff;">]</span>
  <span style="color: #2fafff;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #d8af7a;">[</span>f <span style="color: #79a8ff;">(</span>P 2<span style="color: #79a8ff;">)</span>
        g <span style="color: #79a8ff;">(</span>P 3<span style="color: #79a8ff;">)</span><span style="color: #d8af7a;">]</span>
    <span style="color: #d8af7a;">(</span><span style="color: #79a8ff;">(</span>R x y z<span style="color: #79a8ff;">)</span> f g<span style="color: #d8af7a;">)</span><span style="color: #2fafff;">)</span><span style="color: #ffa00f;">)</span>
</pre>
</div>

<p>
Usage:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">[</span><span style="color: #2fafff;">(</span>ite 1 3 4<span style="color: #2fafff;">)</span> <span style="color: #2fafff;">(</span>ite 0 3 4<span style="color: #2fafff;">)</span><span style="color: #ffa00f;">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">[3 4]
</pre>
</div>

<p>
Head over to the gists to check how we can further define junctors,
modulo, a predicate function that checks if a number is prime, etc.
</p>

<p>
Both a <a href="https://gist.github.com/danielsz/c977ec15c4bb2804052d2493e04a8ed8">Clojure version</a> and a <a href="https://gist.github.com/danielsz/c7e6588c35e523295134133ca38d6943">Scheme version</a> are available.
</p>

<p>
Because it's possible to compose all the familiar arithmetic functions
with this technique, David Hilbert, who instigated the efforts to
rehabilitate the mathematics through finitistic means, conjectured
that all computable functions were primitive recursive. In 1927, two of
his students, Gabriel Sudan and Wilhelm Ackermann, discovered
computable functions that were not primitive recursive.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffa00f;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">sudan</span> <span style="color: #2fafff;">[</span>n x y<span style="color: #2fafff;">]</span>
  <span style="color: #2fafff;">(</span><span style="color: #b6a0ff;">cond</span>
    <span style="color: #d8af7a;">(</span>zero? n<span style="color: #d8af7a;">)</span> <span style="color: #d8af7a;">(</span>+ x y<span style="color: #d8af7a;">)</span>
    <span style="color: #d8af7a;">(</span>zero? y<span style="color: #d8af7a;">)</span> x
    <span style="color: #f78fe7;">:else</span> <span style="color: #d8af7a;">(</span><span style="color: #b6a0ff;">recur</span> <span style="color: #79a8ff;">(</span>dec n<span style="color: #79a8ff;">)</span> <span style="color: #79a8ff;">(</span>sudan n x <span style="color: #cabf00;">(</span>dec y<span style="color: #cabf00;">)</span><span style="color: #79a8ff;">)</span> <span style="color: #79a8ff;">(</span>+ y <span style="color: #cabf00;">(</span>sudan n x <span style="color: #4ae2f0;">(</span>dec y<span style="color: #4ae2f0;">)</span><span style="color: #cabf00;">)</span><span style="color: #79a8ff;">)</span><span style="color: #d8af7a;">)</span><span style="color: #2fafff;">)</span><span style="color: #ffa00f;">)</span>

<span style="color: #ffa00f;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">ackermann</span> <span style="color: #2fafff;">[</span>m n<span style="color: #2fafff;">]</span> 
  <span style="color: #2fafff;">(</span><span style="color: #b6a0ff;">cond</span> <span style="color: #d8af7a;">(</span>zero? m<span style="color: #d8af7a;">)</span> <span style="color: #d8af7a;">(</span>inc n<span style="color: #d8af7a;">)</span>
        <span style="color: #d8af7a;">(</span>zero? n<span style="color: #d8af7a;">)</span> <span style="color: #d8af7a;">(</span>ackermann <span style="color: #79a8ff;">(</span>dec m<span style="color: #79a8ff;">)</span> 1<span style="color: #d8af7a;">)</span>
        <span style="color: #f78fe7;">:else</span> <span style="color: #d8af7a;">(</span>ackermann <span style="color: #79a8ff;">(</span>dec m<span style="color: #79a8ff;">)</span> <span style="color: #79a8ff;">(</span>ackermann m <span style="color: #cabf00;">(</span>dec n<span style="color: #cabf00;">)</span><span style="color: #79a8ff;">)</span><span style="color: #d8af7a;">)</span><span style="color: #2fafff;">)</span><span style="color: #ffa00f;">)</span>
</pre>
</div>

<p>
These functions increase super-exponentially, even for very small
input values. Running the Ackermann function with low values such as m
= 4 results in a <i>StackOverflowError</i>.
</p>

<p>
While primitive recursion doesn't capture all the computable
functions, all functions that are primitive recursive are
computable. In some settings, this is a desirable property. Dennis
Ritchie, author of the C programming language, designed the LOOP
language, restricted to primitive recursion, in order to ask the
question that otherwise would be a non-starter: can one look at a
program and determine an upper bound on its running time? Ritchie
formulated theorems concerning the hierarchy of primitive recursion by
looking at the structure of the loop: its nesting and growth
rate. (Meyer, Albert R. and Ritchie, Dennis M., 1967)
</p>

<p>
Intuitively, primitive recursion corresponds to functions that can be
computed with an understanding in advance about how far one must
search for an answer. General computability includes functions in
which you only need to search finitely far but you don‚Äôt know in
advance how far that might be.
</p>

<p>
The definition of primitive recursive functions implies that their
computation halts on every input (after a finite number of steps). On
the other hand, the halting problem is undecidable for general
recursive functions.
</p>

<p>
In <i>G√∂del, Escher and B√§ch</i>, Douglas Hofstadter devised the BlooP and
the FlooP languages to illustrate the difference between bounded loops
(FOR) and unbounded loops (WHILE, GOTO), corresponding to primitive
recursion and general recursion respectively. Adding unbounded loops
makes the language general recursive and Turing-complete, as are all
real-world computer programming languages. (Hofstadter, Douglas R., 1999)
</p>

<p>
Systems that are Turing complete, like the lambda calculus, the Turing
machine or the ùõç-recursive functions, capture the notion of computable
functions, but in these systems, while mathematically definable, some
functions are not computable. Concrete examples of such functions are
Busy beaver, Kolmogorov complexity, or any function that outputs the
digits of a noncomputable number, such as Chaitin's constant. 
</p>
<div id="outline-container-org96688c5" class="outline-2">
<h2 id="org96688c5">Bibliography</h2>
<div class="outline-text-2" id="text-org96688c5">
<p>
Brainerd, Walter S. and Landweber, Lawrence H. (1974). <i>Theory of Computation</i>, John Wiley \&amp; Sons, Inc..</p>

<p>
Friedman, Daniel P. and Felleisen, Matthias (1996). <i>The little Schemer (4th ed.)</i>, MIT Press.</p>

<p>
Hofstadter, Douglas R. (1999). <i>Godel Escher Bach: An Eternal Golden Braid</i>, Basic Books, Inc..</p>

<p>
Meyer, Albert R. and Ritchie, Dennis M. (1967). <i>The complexity of loop programs</i>, ACM Press.</p>

<p>
Skolem, T. (1923). <i>Begr\"undung der Elementaren Arithmetik durch die rekurrierende Denkweise ohne Anwendung scheinbarer Ver\"anderlichen mit unendlichem Ausdehnungsbereich</i>.</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Justification of elementary arithmetic by the recurrent mindset without the use of apparent variables with infinite extension area.
</p></div></div>


</div>
</div></div>
</body>
</html>
