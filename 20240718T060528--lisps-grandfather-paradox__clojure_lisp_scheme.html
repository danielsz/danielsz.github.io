<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-07-29 Mon 22:21 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lisp's grandfather paradox</title>
<meta name="author" content="Daniel Szmulewicz" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="css/grid.css">
<link rel="stylesheet" type="text/css" href="css/post.css">
<link rel="stylesheet" type="text/css" href="assets/fonts/charter/webfonts/stylesheet.css">
<link rel="stylesheet" type="text/css" href="css/typography.css">
<link href="https://fonts.googleapis.com/css?family=Merriweather+Sans|Roboto+Condensed|Source+Serif+Pro|Inconsolata" rel="stylesheet">
<script src="js/grid.js"></script>
<script src="js/fathom.js"></script>
<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="index.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="content">
<header>
<h1 class="title">Lisp's grandfather paradox</h1>
</header><p>
Recursion is an idea often associated with infinity, a process that
repeats ad aeternam. It is perhaps surprising, then, that the origin
story of mathematical recursion is grounded in finitism, the rejection
of all things infinite.
</p>

<blockquote>
<p>
In 1923, Skolem developed a theory of recursive functions as a means
of avoiding the so-called paradoxes of the infinite in his paper
Begr√ºndung der element√§ren Arithmetik durch die rekurrierende
Denkweise ohne Anwendung scheinbarer Ver√§nderlichen mit unendlichem
Ausdehnugsbereich<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup> (Skolem, T., 1923)
</p>
</blockquote>

<p>
Primitive recursion was originally introduced by Dedekind in 1888, and
proposed as a basis for arithmetic by Skolem in 1923. There is no lack
of mathematical resources describing primitive recursion, but in this
post we are going to try and build an <i>intuition</i> for it. 
</p>

<blockquote>
<p>
We believe that programming languages are the best way to convey the
concept of recursion. They share with mathematics the ability to give
a formal meaning to a set of symbols. But unlike mathematics,
programming languages can be directly experienced-you can take the
programs in this book, observe their behavior, modify them , and
experience the effect of these modifications. (Friedman, Daniel P. and Felleisen, Matthias, 1996)
</p>
</blockquote>

<p>
In <i>The Little Schemer</i>, Daniel Friedman and Matthias Felleisen taught
recursion in Scheme <span class="underline">through dialogue</span>, arguing that the requirements
to be a successful learner was not analytical reasoning but pattern
recognition. To understand the practicalities of recursion in Lisp,
<i>The Little Schemer</i> is indeed a fantastic reference. In contrast, to
understand the theoretical foundation of Lisp, the traditional
treatment of the topic cannot be avoided.
</p>

<p>
Still, our bet is that the use of computer programs can be beneficial
here as well. By faithfully translating the rules of primitive
recursion into a computer program, we hope to breathe life into the
subject. This is the constructivist approach: learning means
<i>constructing</i> an understanding through experience and interaction.
</p>

<p>
The goal of the exercise that follows is an understanding of the
framework of primitive recursion in the terms within which it
appeared. The motivation for this endeavor lies in a quest to tackle
the <i>big ideas</i> at the crossroads of Logic, Mathematics and Computer
Science, such as:
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Foundations_of_mathematics#Foundational_crisis"><i>Grundlagenkrise der Mathematik</i></a></li>
<li><a href="https://en.wikipedia.org/wiki/Finitism">Finitism</a></li>
<li><a href="https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems">G√∂del's arithmetization of syntax</a></li>
<li><a href="https://en.wikipedia.org/wiki/Computability_theory">Recursion theory</a></li>
<li><a href="https://en.wikipedia.org/wiki/McCarthy_Formalism">The origins of Lisp</a></li>
</ul>

<p>
It might be interesting to start with a quick glance at the
traditional presentation of the topic. Wikipedia has a decent <a href="https://en.wikipedia.org/wiki/Primitive_recursive_function">entry</a>,
<a href="https://plato.stanford.edu/entries/recursive-functions/">Stanford Encyclopedia of Philosophy</a> too. Take a look at the formulas
describing primitive recursion, no matter how opaque. At the end of
our exercise, we will have a basis of comparison. We might answer the
question how Lisp improves our understanding.
</p>

<p>
<i>Note:</i> We are going to stick close to some conventions found in the
traditional treatment of the topic, up to the capitalized one-letter
naming scheme for functions. This will make it easy for learners to
switch back and forth between the code and the formalism. Please do
not hesitate to replace the one-letter function names with something
more palatable. And remember that you can trace the execution of the
functions in the REPL.
</p>

<p>
Primitive recursion is not complicated, but surprising. Indeed,
it takes only three initial functions closed under two operations to
produce all of the familiar functions on the natural numbers.
</p>

<blockquote>
<p>
&#x2026; most computable functions that are studied in number theory (and
more generally in mathematics) are primitive recursive. For example,
addition and division, the factorial and exponential function, and the
function which returns the nth prime are all primitive
recursive. (Brainerd, Walter S. and Landweber, Lawrence H., 1974)
</p>
</blockquote>

<p>
Our first rule is the Zero rule.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span><span style="color: #531ab6;">def</span> <span style="color: #005e8b;">Z</span> #<span style="color: #695500;">(</span><span style="color: #531ab6;">fn</span> <span style="color: #3548cf;">[</span>&amp; _<span style="color: #3548cf;">]</span> 0<span style="color: #695500;">)</span><span style="color: #0031a9;">)</span>
</pre>
</div>

<p>
This function returns a function that takes any number of arguments
and always returns zero. 
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">[</span><span style="color: #695500;">(</span><span style="color: #3548cf;">(</span>Z<span style="color: #3548cf;">)</span><span style="color: #695500;">)</span> <span style="color: #695500;">(</span><span style="color: #3548cf;">(</span>Z<span style="color: #3548cf;">)</span> 5<span style="color: #695500;">)</span> <span style="color: #695500;">(</span><span style="color: #3548cf;">(</span>Z<span style="color: #3548cf;">)</span> 1 2 3<span style="color: #695500;">)</span><span style="color: #0031a9;">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">[0 0 0]
</pre>
</div>

<p>
Our second basic function is the <a href="https://en.wikipedia.org/wiki/Successor_function">successor function</a>. Yes, <a href="https://en.wikipedia.org/wiki/Successor_function">that one</a>
from <a href="https://en.wikipedia.org/wiki/Peano_axioms">number theory</a>. It isn't more complicated as our zero function: it
increments a number by one.
</p>

<p>
It is identical to <code>inc</code> in Clojure, so we will just alias it.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span><span style="color: #531ab6;">def</span> <span style="color: #005e8b;">S</span> inc<span style="color: #0031a9;">)</span>
</pre>
</div>

<p>
Our last basic function is trickier to explain because its purpose may
not be immediately apparent. It is called the projection function, and
it picks an element from a sequence. Its role is auxiliary, but
nonetheless crucial. It is used to configure primitive recursion by
rearranging function arguments. We will see it in action soon.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span><span style="color: #531ab6;">defn</span> <span style="color: #721045;">P</span> <span style="color: #695500;">[</span>i<span style="color: #695500;">]</span>
  <span style="color: #695500;">(</span><span style="color: #531ab6;">fn</span> <span style="color: #3548cf;">[</span>&amp; args<span style="color: #3548cf;">]</span> <span style="color: #3548cf;">(</span>nth args <span style="color: #77492f;">(</span>dec i<span style="color: #77492f;">)</span><span style="color: #3548cf;">)</span><span style="color: #695500;">)</span><span style="color: #0031a9;">)</span>
</pre>
</div>

<p>
<i>Note:</i> The projection function is not zero-based, but the ArraySeq
containing the arguments is, so we make the decrement adjustment.
</p>

<p>
Our first operation is composition. We will call it capital
C. Remember, the initial or basic functions operate on natural
numbers, the operations act on those initial functions.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span><span style="color: #531ab6;">defn</span> <span style="color: #721045;">C</span> <span style="color: #695500;">[</span>f &amp; gs<span style="color: #695500;">]</span>
  <span style="color: #695500;">(</span><span style="color: #531ab6;">fn</span> <span style="color: #3548cf;">[</span>&amp; xs<span style="color: #3548cf;">]</span> <span style="color: #3548cf;">(</span>apply f <span style="color: #77492f;">(</span>map #<span style="color: #0000b0;">(</span>apply <span style="color: #005e8b;">%</span> xs<span style="color: #0000b0;">)</span> gs<span style="color: #77492f;">)</span><span style="color: #3548cf;">)</span><span style="color: #695500;">)</span><span style="color: #0031a9;">)</span>
</pre>
</div>

<p>
Composition takes a function ùëì and any number of functions ùëî, and
returns a function that receives any number of arguments and applies f
to the result of applying functions ùëî on those arguments.
</p>

<p>
In some textbooks it is called the substitution operator; it is used
for substituting constants, permuting variable and composing functions.
</p>

<p>
The following usage example may help.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span><span style="color: #695500;">(</span>C S <span style="color: #3548cf;">(</span>P 1<span style="color: #3548cf;">)</span><span style="color: #695500;">)</span> 5 11<span style="color: #0031a9;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">6
</pre>
</div>

<p>
Contrast with:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span><span style="color: #695500;">(</span>C S <span style="color: #3548cf;">(</span>P 2<span style="color: #3548cf;">)</span><span style="color: #695500;">)</span> 5 11<span style="color: #0031a9;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">12
</pre>
</div>

<p>
Finally, the recursion operation.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span><span style="color: #531ab6;">defn</span> <span style="color: #721045;">R</span> <span style="color: #695500;">[</span>n &amp; xs<span style="color: #695500;">]</span>
  <span style="color: #695500;">(</span><span style="color: #531ab6;">fn</span> <span style="color: #3548cf;">[</span>f g<span style="color: #3548cf;">]</span>
    <span style="color: #3548cf;">(</span><span style="color: #531ab6;">loop</span> <span style="color: #77492f;">[</span>i 1
           j 0
           acc <span style="color: #0000b0;">(</span>apply f xs<span style="color: #0000b0;">)</span><span style="color: #77492f;">]</span>
      <span style="color: #77492f;">(</span><span style="color: #531ab6;">if</span> <span style="color: #0000b0;">(</span>&lt;= i n<span style="color: #0000b0;">)</span>
        <span style="color: #0000b0;">(</span><span style="color: #531ab6;">recur</span> <span style="color: #973300;">(</span>inc i<span style="color: #973300;">)</span> <span style="color: #973300;">(</span>inc j<span style="color: #973300;">)</span> <span style="color: #973300;">(</span>apply <span style="color: #003497;">(</span>partial g j acc<span style="color: #003497;">)</span> xs<span style="color: #973300;">)</span><span style="color: #0000b0;">)</span>
        acc<span style="color: #77492f;">)</span><span style="color: #3548cf;">)</span><span style="color: #695500;">)</span><span style="color: #0031a9;">)</span>
</pre>
</div>

<p>
Function ùëì is used for the initial computation only. After such
initialization, function ùëî is proceeding by applying its rules,
whatever they may be, on the previous computed value. Hence, the
recursion.
</p>

<p>
The most important thing to notice here is that the recursion is
bounded. In other words, we know in advance the number of times the
procedure will repeat itself, namely, ùêß number of times. Primitive
recursion is always bounded, it is guaranteed to halt.
</p>

<p>
Now that we have the pieces in place we can start to build our algebra
of primitive recursive functions.  Have you noticed that conspicuously
absent from our framework are the natural numbers themselves?
Following the principle of induction, we can generate the natural
numbers with zero and the successor function.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span><span style="color: #531ab6;">defn</span> <span style="color: #721045;">k</span> <span style="color: #695500;">[</span>n<span style="color: #695500;">]</span>
  <span style="color: #695500;">(</span><span style="color: #531ab6;">fn</span> <span style="color: #3548cf;">[</span>&amp; _<span style="color: #3548cf;">]</span>
    <span style="color: #3548cf;">(</span><span style="color: #531ab6;">let</span> <span style="color: #77492f;">[</span>f <span style="color: #0000b0;">(</span>Z<span style="color: #0000b0;">)</span>
          g <span style="color: #0000b0;">(</span>C S <span style="color: #973300;">(</span>P 1<span style="color: #973300;">)</span><span style="color: #0000b0;">)</span><span style="color: #77492f;">]</span>
      <span style="color: #77492f;">(</span><span style="color: #0000b0;">(</span>R n<span style="color: #0000b0;">)</span> f g<span style="color: #77492f;">)</span><span style="color: #3548cf;">)</span><span style="color: #695500;">)</span><span style="color: #0031a9;">)</span>
</pre>
</div>

<p>
Usage:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">[</span><span style="color: #695500;">(</span><span style="color: #3548cf;">(</span>k 5<span style="color: #3548cf;">)</span> 5<span style="color: #695500;">)</span> <span style="color: #695500;">(</span><span style="color: #3548cf;">(</span>k 5<span style="color: #3548cf;">)</span> 6<span style="color: #695500;">)</span> <span style="color: #695500;">(</span><span style="color: #3548cf;">(</span>k 5<span style="color: #3548cf;">)</span> 7<span style="color: #695500;">)</span><span style="color: #0031a9;">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">[5 5 5]
</pre>
</div>

<p>
No matter what the input is, the function returns the number of times
we applied the successor function starting from zero. 
</p>

<p>
Addition is achieved by applying the successor function ùê± times on
ùê≤ + 1.  
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span><span style="color: #531ab6;">defn</span> <span style="color: #721045;">add</span> <span style="color: #695500;">[</span>x y<span style="color: #695500;">]</span>
  <span style="color: #695500;">(</span><span style="color: #531ab6;">let</span> <span style="color: #3548cf;">[</span>f <span style="color: #77492f;">(</span>P 1<span style="color: #77492f;">)</span>
        g <span style="color: #77492f;">(</span>C S <span style="color: #0000b0;">(</span>P 2<span style="color: #0000b0;">)</span><span style="color: #77492f;">)</span><span style="color: #3548cf;">]</span>
    <span style="color: #3548cf;">(</span><span style="color: #77492f;">(</span>R x y<span style="color: #77492f;">)</span> f g<span style="color: #3548cf;">)</span><span style="color: #695500;">)</span><span style="color: #0031a9;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span>add 4 5<span style="color: #0031a9;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">9
</pre>
</div>

<p>
We can leverage addition to define multiplication.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span><span style="color: #531ab6;">defn</span> <span style="color: #721045;">mul</span> <span style="color: #695500;">[</span>x y<span style="color: #695500;">]</span>
  <span style="color: #695500;">(</span><span style="color: #531ab6;">let</span> <span style="color: #3548cf;">[</span>f <span style="color: #77492f;">(</span>Z<span style="color: #77492f;">)</span>
        g <span style="color: #77492f;">(</span>C add <span style="color: #0000b0;">(</span>P 2<span style="color: #0000b0;">)</span> <span style="color: #0000b0;">(</span>P 3<span style="color: #0000b0;">)</span><span style="color: #77492f;">)</span><span style="color: #3548cf;">]</span>
    <span style="color: #3548cf;">(</span><span style="color: #77492f;">(</span>R x y<span style="color: #77492f;">)</span> f g<span style="color: #3548cf;">)</span><span style="color: #695500;">)</span><span style="color: #0031a9;">)</span>
</pre>
</div>

<p>
Usage:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span>mul 6 7<span style="color: #0031a9;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">42
</pre>
</div>

<p>
By definition, any function composed from the basic function and the
operations is primitive recursive. Likewise, any derivation, like
addition or multiplication, is also primitive recursive. This is how
we develop the algebra of primitive recursive functions.
</p>

<p>
Factorial leverages multiplication, predictably. As does exponentiation.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span><span style="color: #531ab6;">defn</span> <span style="color: #721045;">fac</span> <span style="color: #695500;">[</span>n<span style="color: #695500;">]</span>
  <span style="color: #695500;">(</span><span style="color: #531ab6;">let</span> <span style="color: #3548cf;">[</span>f <span style="color: #77492f;">(</span>k 1<span style="color: #77492f;">)</span>
        g <span style="color: #77492f;">(</span>C mul <span style="color: #0000b0;">(</span>P 2<span style="color: #0000b0;">)</span> <span style="color: #0000b0;">(</span>C S <span style="color: #973300;">(</span>P 1<span style="color: #973300;">)</span><span style="color: #0000b0;">)</span><span style="color: #77492f;">)</span><span style="color: #3548cf;">]</span>
    <span style="color: #3548cf;">(</span><span style="color: #77492f;">(</span>R n<span style="color: #77492f;">)</span> f g<span style="color: #3548cf;">)</span><span style="color: #695500;">)</span><span style="color: #0031a9;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">[</span><span style="color: #695500;">(</span>fac 3<span style="color: #695500;">)</span> <span style="color: #695500;">(</span>fac 4<span style="color: #695500;">)</span> <span style="color: #695500;">(</span>fac 5<span style="color: #695500;">)</span><span style="color: #0031a9;">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">[6 24 120]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span><span style="color: #531ab6;">defn</span> <span style="color: #721045;">pow</span> <span style="color: #695500;">[</span>x y<span style="color: #695500;">]</span>
  <span style="color: #695500;">(</span><span style="color: #531ab6;">let</span> <span style="color: #3548cf;">[</span>f <span style="color: #77492f;">(</span>k 1<span style="color: #77492f;">)</span>
        g <span style="color: #77492f;">(</span>C mul <span style="color: #0000b0;">(</span>P 2<span style="color: #0000b0;">)</span> <span style="color: #0000b0;">(</span>P 3<span style="color: #0000b0;">)</span><span style="color: #77492f;">)</span><span style="color: #3548cf;">]</span>
    <span style="color: #3548cf;">(</span><span style="color: #77492f;">(</span>R y x<span style="color: #77492f;">)</span> f g<span style="color: #3548cf;">)</span><span style="color: #695500;">)</span><span style="color: #0031a9;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">[</span><span style="color: #695500;">(</span>pow 3 4<span style="color: #695500;">)</span> <span style="color: #695500;">(</span>pow 4 3<span style="color: #695500;">)</span> <span style="color: #695500;">(</span>pow 4 5<span style="color: #695500;">)</span> <span style="color: #695500;">(</span>pow 5 4<span style="color: #695500;">)</span><span style="color: #0031a9;">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">[81 64 1024 625]
</pre>
</div>

<p>
By interpreting 1 and 0 as boolean values, we can define predicates,
like <code>zero?</code>.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span><span style="color: #531ab6;">defn</span> <span style="color: #721045;">z</span> <span style="color: #695500;">[</span>n<span style="color: #695500;">]</span>
  <span style="color: #695500;">(</span><span style="color: #531ab6;">let</span> <span style="color: #3548cf;">[</span>f <span style="color: #77492f;">(</span>k 1<span style="color: #77492f;">)</span>
        g <span style="color: #77492f;">(</span>Z<span style="color: #77492f;">)</span><span style="color: #3548cf;">]</span>
    <span style="color: #3548cf;">(</span><span style="color: #77492f;">(</span>R n<span style="color: #77492f;">)</span> f g<span style="color: #3548cf;">)</span><span style="color: #695500;">)</span><span style="color: #0031a9;">)</span>
</pre>
</div>

<p>
Usage:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">[</span><span style="color: #695500;">(</span>z 0<span style="color: #695500;">)</span> <span style="color: #695500;">(</span>z 1<span style="color: #695500;">)</span> <span style="color: #695500;">(</span>z 2<span style="color: #695500;">)</span><span style="color: #0031a9;">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">[1 0 0]
</pre>
</div>

<p>
And now we can define an if-then-else function.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span><span style="color: #531ab6;">defn</span> <span style="color: #721045;">ite</span> <span style="color: #695500;">[</span>x y z<span style="color: #695500;">]</span>
  <span style="color: #695500;">(</span><span style="color: #531ab6;">let</span> <span style="color: #3548cf;">[</span>f <span style="color: #77492f;">(</span>P 2<span style="color: #77492f;">)</span>
        g <span style="color: #77492f;">(</span>P 3<span style="color: #77492f;">)</span><span style="color: #3548cf;">]</span>
    <span style="color: #3548cf;">(</span><span style="color: #77492f;">(</span>R x y z<span style="color: #77492f;">)</span> f g<span style="color: #3548cf;">)</span><span style="color: #695500;">)</span><span style="color: #0031a9;">)</span>
</pre>
</div>

<p>
Usage:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">[</span><span style="color: #695500;">(</span>ite 1 3 4<span style="color: #695500;">)</span> <span style="color: #695500;">(</span>ite 0 3 4<span style="color: #695500;">)</span><span style="color: #0031a9;">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-org">[3 4]
</pre>
</div>

<p>
Head over to the gists to check how we can further define junctors,
modulo, a predicate function that checks if a number is prime, etc.
</p>

<p>
Both a <a href="https://gist.github.com/danielsz/c977ec15c4bb2804052d2493e04a8ed8">Clojure version</a> and a <a href="https://gist.github.com/danielsz/c7e6588c35e523295134133ca38d6943">Scheme version</a> are available.
</p>

<div class="hiring" id="org1604263">
<p>
<b>Open for work</b>
</p>

<p>
Are you hiring? Do you know someone that is? Looking for a
collaborator? A team lead or member? A consultant, maybe? Need a
little boost or a long-term commitment? Let's <a href="mailto:daniel.szmulewicz@gmail.com?subject=We%20are%20hiring">talk</a>.
</p>

</div>

<p>
Because it's possible to compose all the familiar arithmetic functions
within the framework of primitive recursion, David Hilbert, who
instigated the efforts to rehabilitate mathematics through finitistic
means, conjectured that all computable functions were primitive
recursive. In 1927, two of his students, Gabriel Sudan and Wilhelm
Ackermann, proved him wrong.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0031a9;">(</span><span style="color: #531ab6;">defn</span> <span style="color: #721045;">sudan</span> <span style="color: #695500;">[</span>n x y<span style="color: #695500;">]</span>
  <span style="color: #695500;">(</span><span style="color: #531ab6;">cond</span>
    <span style="color: #3548cf;">(</span>zero? n<span style="color: #3548cf;">)</span> <span style="color: #3548cf;">(</span>+ x y<span style="color: #3548cf;">)</span>
    <span style="color: #3548cf;">(</span>zero? y<span style="color: #3548cf;">)</span> x
    <span style="color: #8f0075;">:else</span> <span style="color: #3548cf;">(</span><span style="color: #531ab6;">recur</span> <span style="color: #77492f;">(</span>dec n<span style="color: #77492f;">)</span> <span style="color: #77492f;">(</span>sudan n x <span style="color: #0000b0;">(</span>dec y<span style="color: #0000b0;">)</span><span style="color: #77492f;">)</span> <span style="color: #77492f;">(</span>+ y <span style="color: #0000b0;">(</span>sudan n x <span style="color: #973300;">(</span>dec y<span style="color: #973300;">)</span><span style="color: #0000b0;">)</span><span style="color: #77492f;">)</span><span style="color: #3548cf;">)</span><span style="color: #695500;">)</span><span style="color: #0031a9;">)</span>

<span style="color: #0031a9;">(</span><span style="color: #531ab6;">defn</span> <span style="color: #721045;">ackermann</span> <span style="color: #695500;">[</span>m n<span style="color: #695500;">]</span> 
  <span style="color: #695500;">(</span><span style="color: #531ab6;">cond</span> <span style="color: #3548cf;">(</span>zero? m<span style="color: #3548cf;">)</span> <span style="color: #3548cf;">(</span>inc n<span style="color: #3548cf;">)</span>
        <span style="color: #3548cf;">(</span>zero? n<span style="color: #3548cf;">)</span> <span style="color: #3548cf;">(</span>ackermann <span style="color: #77492f;">(</span>dec m<span style="color: #77492f;">)</span> 1<span style="color: #3548cf;">)</span>
        <span style="color: #8f0075;">:else</span> <span style="color: #3548cf;">(</span>ackermann <span style="color: #77492f;">(</span>dec m<span style="color: #77492f;">)</span> <span style="color: #77492f;">(</span>ackermann m <span style="color: #0000b0;">(</span>dec n<span style="color: #0000b0;">)</span><span style="color: #77492f;">)</span><span style="color: #3548cf;">)</span><span style="color: #695500;">)</span><span style="color: #0031a9;">)</span>
</pre>
</div>

<p>
These functions increase super-exponentially, even for very small
input values. Running the Ackermann function with <code>m = 4</code> results in a
<i>StackOverflowError</i> and no optimizations are straightforward to
leverage, not tail recursion, not managing the call stack manually in
heap memory.
</p>

<p>
While primitive recursion doesn't capture all the computable
functions, all functions that are primitive recursive are
computable. In some settings, this is a desirable property. Dennis
Ritchie, author of the C programming language, designed the LOOP
language, restricted to primitive recursion, in order to ask the
question that otherwise would be a non-starter: can one look at a
program and determine an upper bound on its running time? Then he went
on formulating theorems concerning the hierarchy of primitive
recursion by looking at the structure of the loop, its nesting depth
and the growth rate. (Meyer, Albert R. and Ritchie, Dennis M., 1967)
</p>

<p>
Intuitively, primitive recursion corresponds to functions that can be
computed with an understanding in advance about how far one must
search for an answer. General computability includes functions in
which one needs to search finitely far but without knowing how far
that might be.
</p>

<p>
In <i>G√∂del, Escher and B√§ch</i>, Douglas Hofstadter devised the BlooP and
the FlooP languages to illustrate the difference between bounded loops
(FOR) and unbounded loops (WHILE, GOTO), corresponding to primitive
recursion and general recursion respectively. Adding unbounded loops
makes the language general recursive and Turing-complete, as are all
real-world computer programming languages. (Hofstadter, Douglas R., 1999)
</p>

<p>
The definition of primitive recursive functions implies that their
computation halts on every input (after a finite number of steps). On
the other hand, the halting problem is undecidable for general
recursive functions.
</p>

<p>
Systems that are Turing complete, like the lambda calculus, the Turing
machine or the ùõç-recursive functions (aka general recursive functions,
aka partial recursive functions), capture the notion of computable
functions, but in these systems, while mathematically definable, some
functions are not computable. (Rado, T., 1962)
</p>

<blockquote>
<p>
My desire for an algebraic list processing language for artificial
intelligence work on the IBM 704 computer arose in the summer of 1956
during the Dartmouth Summer Research Project on Artificial
Intelligence which was the first organized study of AI&#x2026; While
expressions could be handled easily in FLPL, and it was used
successfully for the Geometry program, it had neither conditional
expressions nor recursion, and erasing list structure was handled
explicitly by the program. (McCarthy, John, 1978)
</p>
</blockquote>

<p>
John McCarthy based Lisp on general recursion, but devised it to
operate on symbols rather than numbers. He was interested in AI, where
concepts, the way humans manipulate them, occupy the center stage. A
symbol can stand in for any idea, whether code or data. Just today
we've seen just how expressive symbolic expressions are, effortlessly
encoding the formulas of primitive recursion. Somehow we have made
Lisp revisit its conceptual ancestor. We've traveled in time like in
the grandfather paradox.  Not with the intent to kill the progenitor,
but rather to embrace him, bring him back to life, even if for a
moment.
</p>

<div class="contact" id="org8d73e6a">
<p>
Wow, you've made it! Right up to the end! So you're into this kind of
stuff, aren't you?! Maybe we should be friends! What's more, I might
be writing more on the topic. Would you like to be notified? Also, I'm
gauging interest in long-form writing, maybe a book. If that's
something you'd sign up for, please let me <a href="mailto:daniel.szmulewicz@gmail.com?subject=More%20of%20this%20stuff%20please">know</a>.
</p>

</div>

<div class="bibliography" id="org118dcd1">
<p>
Bibliography
</p>

<p>
Brainerd, Walter S. and Landweber, Lawrence H. (1974). <i>Theory of Computation</i>, John Wiley \&amp; Sons, Inc..</p>

<p>
Friedman, Daniel P. and Felleisen, Matthias (1996). <i>The little Schemer (4th ed.)</i>, MIT Press.</p>

<p>
Hofstadter, Douglas R. (1999). <i>Godel Escher Bach: An Eternal Golden Braid</i>, Basic Books, Inc..</p>

<p>
McCarthy, John (1978). <i>History of LISP</i>, Association for Computing Machinery (ACM).</p>

<p>
Meyer, Albert R. and Ritchie, Dennis M. (1967). <i>The complexity of loop programs</i>, ACM Press.</p>

<p>
Rado, T. (1962). <i>On Non-Computable Functions</i>, Institute of Electrical and Electronics Engineers (IEEE).</p>

<p>
Skolem, T. (1923). <i>Begr{\"u}ndung der Elementaren Arithmetik durch die rekurrierende Denkweise ohne Anwendung scheinbarer Ver{\"a}nderlichen mit unendlichem Ausdehnungsbereich</i>.</p>

</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Justification of elementary arithmetic by the recurrent mindset without the use of apparent variables with infinite extension area.
</p></div></div>


</div>
</div></div>
</body>
</html>
