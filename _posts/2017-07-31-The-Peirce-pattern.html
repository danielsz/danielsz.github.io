---
title: The Peirce pattern
layout: post
tags: clojure idempotency side_effects patterns
categories: clojure idempotency side_effects patterns
---



<p>
So let’s say we want to send a newsletter to our users. Easy enough.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #a020f0;">doseq</span> <span style="color: #7388d6;">[</span>user users<span style="color: #7388d6;">]</span>
  <span style="color: #7388d6;">(</span>send-newsletter user<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Oh bugger! The command failed midway, and now you need to resend the
newsletter to only a portion of the users. But who has gotten our newsletter,
and who hasn’t?
</p>

<p>
Back to the whiteboard.
</p>

<p>
We need to track the success of the sending operation, and log it
along with our user entity. In other words, we need a logbook.
</p>

<p>
Our logbook may look like this:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">{</span><span style="color: #008b8b;">:logbook</span> <span style="color: #7388d6;">[</span><span style="color: #909183;">{</span><span style="color: #008b8b;">:newsletter</span> timestamp<span style="color: #909183;">}</span><span style="color: #7388d6;">]</span><span style="color: #707183;">}</span>
</pre>
</div>

<p>
Over time, we will send many newsletters, and our logbook will look like this:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">{</span><span style="color: #008b8b;">:logbook</span> <span style="color: #7388d6;">[</span><span style="color: #909183;">{</span><span style="color: #008b8b;">:newsletter</span> timestamp<span style="color: #909183;">}</span>
           <span style="color: #909183;">{</span><span style="color: #008b8b;">:newsletter</span> timestamp<span style="color: #909183;">}</span>
           <span style="color: #909183;">{</span><span style="color: #008b8b;">:newsletter</span> timestamp<span style="color: #909183;">}</span><span style="color: #7388d6;">]</span><span style="color: #707183;">}</span>
</pre>
</div>

<p>
A logbook is flexible because you can record all kinds of events that occured with regards to an entity. 
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">{</span><span style="color: #008b8b;">:first-name</span> <span style="color: #8b2252;">"Benjamin"</span>
 <span style="color: #008b8b;">:last-name</span> <span style="color: #8b2252;">"Peirce"</span>
 <span style="color: #008b8b;">:occupation</span> <span style="color: #8b2252;">"Mathematician"</span>
 <span style="color: #008b8b;">:email</span> <span style="color: #8b2252;">"benjamin.peirce@harvard.edu"</span>
 <span style="color: #008b8b;">:logbook</span> <span style="color: #7388d6;">[</span><span style="color: #909183;">{</span><span style="color: #008b8b;">:welcome-email</span> timestamp<span style="color: #909183;">}</span>
           <span style="color: #909183;">{</span><span style="color: #008b8b;">:subscription-reminder</span> timestamp<span style="color: #909183;">}</span>
           <span style="color: #909183;">{</span><span style="color: #008b8b;">:subscription-reminder</span> timestamp<span style="color: #909183;">}</span>
           <span style="color: #909183;">{</span><span style="color: #008b8b;">:newsletter</span> timestamp<span style="color: #909183;">}</span>
           <span style="color: #909183;">{</span><span style="color: #008b8b;">:newsletter</span> timestamp<span style="color: #909183;">}</span>
           <span style="color: #909183;">{</span><span style="color: #008b8b;">:newsletter</span> timestamp<span style="color: #909183;">}</span><span style="color: #7388d6;">]</span><span style="color: #707183;">}</span>
</pre>
</div>

<p>
We can tell at first glance that we have sent our user a welcome email, two subscription reminders and three newsletters.
</p>

<p>
How shall we achieve idempotency for our communication operations? In other words, we want to run the <code>send-newsletter</code> multiple times, and still be sure that the newsletter gets sent only if it needs to be. 
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #a020f0;">doseq</span> <span style="color: #7388d6;">[</span>user users
        <span style="color: #008b8b;">:when</span> <span style="color: #909183;">(</span>some <span style="color: #709870;">(</span><span style="color: #a020f0;">fn</span> <span style="color: #907373;">[</span>entry<span style="color: #907373;">]</span> <span style="color: #907373;">(</span>is-timestamp-within-range <span style="color: #a0522d;">%</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span> <span style="color: #709870;">(</span>filter <span style="color: #008b8b;">:newsletter</span> <span style="color: #907373;">(</span><span style="color: #008b8b;">:logbook</span> user<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">]</span>
  <span style="color: #7388d6;">(</span>send-newsletter user<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
We send our newsletters once a month, so the <code>is-timestamp-within-range</code> predicate checks if the recorded timestamp falls in that interval.
Our welcome email gets sent only once, so an idempotent <code>send-welcome-email</code> would look a little bit different:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #a020f0;">doseq</span> <span style="color: #7388d6;">[</span>user users
        <span style="color: #008b8b;">:when</span> <span style="color: #909183;">(</span>empty? <span style="color: #709870;">(</span>filter <span style="color: #008b8b;">:welcome-email</span> <span style="color: #907373;">(</span><span style="color: #008b8b;">:logbook</span> user<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">]</span>
  <span style="color: #7388d6;">(</span>send-welcome-email user<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
In other words, we architecture our operations around events and predicates. 
In our example, the events are <code>:welcome-email</code>, <code>:subscription-reminder</code> and <code>:newsletter</code>. 
We can standardize our predicates and decide that they will operate on a logbook entry (if found):
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">unique?</span> #<span style="color: #7388d6;">(</span>some? <span style="color: #a0522d;">%</span><span style="color: #7388d6;">)</span>
<span style="color: #7388d6;">(</span><span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">last-month?</span> #<span style="color: #909183;">(</span><span style="color: #a020f0;">if-let</span> <span style="color: #709870;">[</span>date <span style="color: #907373;">(</span>first <span style="color: #6276ba;">(</span>vals <span style="color: #a0522d;">%</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">]</span>
                     <span style="color: #709870;">(</span><span style="color: #228b22;">time</span><span style="color: #000000; background-color: #ffffff;">/</span>last-month? date<span style="color: #709870;">)</span>
                     <span style="color: #008b8b;">false</span><span style="color: #909183;">)</span>
</pre>
</div>

<p>
This allows us to compose them neatly with logbook sequences.
</p>

<pre class="example">
(some unique? (filter :welcome-email (:logbook user)))
</pre>

<pre class="example">
(some last-month? (filter :newsletter (:logbook user)))
</pre>

<p>
Now let’s look back at our newsletter sending operation. 
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #a020f0;">doseq</span> <span style="color: #7388d6;">[</span>user users
        <span style="color: #008b8b;">:when</span> <span style="color: #909183;">(</span>some last-month? <span style="color: #709870;">(</span>filter <span style="color: #008b8b;">:newsletter</span> <span style="color: #907373;">(</span><span style="color: #008b8b;">:logbook</span> user<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">]</span>
  <span style="color: #7388d6;">(</span>send-newsletter user<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Something is missing, right?
If the newsletter is sent successfully, we need to write an entry in the logbook. 
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #a020f0;">doseq</span> <span style="color: #7388d6;">[</span>user users
        <span style="color: #008b8b;">:when</span> <span style="color: #909183;">(</span>some last-month? <span style="color: #709870;">(</span>filter <span style="color: #008b8b;">:newsletter</span> <span style="color: #907373;">(</span><span style="color: #008b8b;">:logbook</span> user<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">]</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">let</span> <span style="color: #909183;">[</span>response <span style="color: #709870;">(</span>send-newsletter user<span style="color: #709870;">)</span><span style="color: #909183;">]</span>
    <span style="color: #909183;">(</span><span style="color: #a020f0;">when</span> <span style="color: #709870;">(</span>success? response<span style="color: #709870;">)</span>
      <span style="color: #709870;">(</span>write-to-logbook user<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
If you have some experience writing web applications, you probably
recognize this pattern. In REST APIS, <code>put</code> and <code>delete</code> operations
have similar semantics.
</p>

<p>
I call it the “Peirce pattern”, after the American mathematician who
coined the term “idempotency”. 
</p>

<blockquote>
<p>
In computing, an idempotent operation is one that has no additional effect if it is called more than once with the same input parameters. 
In mathematics, an idempotent operation is one where <i>f</i> (<i>f</i> (x)) = <i>f</i> (x).
</p>
</blockquote>

<blockquote>
<p>
Idempotent operations are often used in the design of network protocols, where a request to perform an operation is guaranteed to happen at least once, but might also happen more than once. If the operation is idempotent, then there is no harm in performing the operation two or more times.
</p>
</blockquote>

<p>
If you have read SICP, you may remember how we muster means of abstraction to generalize a problem. This allows us in turn to devise a solution for a whole class of related problems. What our solution lacks is generality. 
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #a020f0;">doseq</span> <span style="color: #7388d6;">[</span>user users
        <span style="color: #008b8b;">:when</span> <span style="color: #909183;">(</span>some last-month? <span style="color: #709870;">(</span>filter <span style="color: #008b8b;">:newsletter</span> <span style="color: #907373;">(</span><span style="color: #008b8b;">:logbook</span> user<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">]</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">let</span> <span style="color: #909183;">[</span>response <span style="color: #709870;">(</span>send-newsletter user<span style="color: #709870;">)</span><span style="color: #909183;">]</span>
    <span style="color: #909183;">(</span><span style="color: #a020f0;">when</span> <span style="color: #709870;">(</span>success? response<span style="color: #709870;">)</span>
      <span style="color: #709870;">(</span>write-to-logbook user<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
This ad-hoc snippet really boils down to:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #a020f0;">doseq</span> <span style="color: #7388d6;">[</span>entity entities
        <span style="color: #008b8b;">:when</span> <span style="color: #909183;">(</span>some pred logbook<span style="color: #909183;">)</span><span style="color: #7388d6;">]</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">let</span> <span style="color: #909183;">[</span>response <span style="color: #709870;">(</span>operation entity<span style="color: #709870;">)</span><span style="color: #909183;">]</span>
    <span style="color: #909183;">(</span><span style="color: #a020f0;">when</span> <span style="color: #709870;">(</span>success? response<span style="color: #709870;">)</span>
      <span style="color: #709870;">(</span>persist entity<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
With proper design and the magic of macros, we can actually write the following:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #a020f0;">doseq</span> <span style="color: #7388d6;">[</span>entity entities<span style="color: #7388d6;">]</span>
  <span style="color: #7388d6;">(</span>with-logbook entity event
    <span style="color: #909183;">(</span>operation entity<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
The entity (<code>user</code>), the operation (<code>send-newsletter</code>) and the event
(the choice of predicate) have been abstracted. 
</p>

<p>
All the rest has been made implicit: how we retrieve the logbook for an entity, how we determine if the operation was successful, how we
append events to the logbook. Instead of cluttering the calling site, the user makes those assumptions explicit via a configuration mechanism.
</p>

<p>
This is the value proposal of Benjamin. It relies on traditional Lisp features such as macros and dynamic scope. It is not guaranteed to fit all use cases, but chances are it will some.
</p>

<p>
Check it out on github.
</p>

<p>
Benjamin: an open-source library that formalizes a Lispy way to implement idempotency with side-effects.  
</p>
