---
title: The Peirce pattern
layout: post
tags: clojure idempotency side_effects patterns
categories: clojure idempotency side_effects patterns
---




<div class="figure">
<p><img src="images/benjamin.jpg" alt="benjamin.jpg" />
</p>
</div>

<p>
TL:DR; Benjamin: an open-source library that formalizes a Lispy way to implement idempotency with side-effects.  
</p>

<p>
So let’s say we want to send a newsletter to our users. Easy enough.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #b48ead;">doseq</span> <span style="color: #93a8c6;">[</span>user users<span style="color: #93a8c6;">]</span>
  <span style="color: #93a8c6;">(</span>send-newsletter user<span style="color: #93a8c6;">)</span><span style="color: #8c8c8c;">)</span>
</pre>
</div>

<p>
Oh bugger! The command failed midway, and now you need to resend the
newsletter to only a portion of the users. But who has gotten our newsletter,
and who hasn’t?
</p>

<p>
Back to the whiteboard.
</p>

<p>
We need to track the success of the sending operation, and log it
along with our user entity. In other words, we need a logbook.
</p>

<p>
Our logbook may look like this:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">{</span><span style="color: #d08770;">:logbook</span> <span style="color: #93a8c6;">[</span><span style="color: #b0b1a3;">{</span><span style="color: #d08770;">:newsletter</span> timestamp<span style="color: #b0b1a3;">}</span><span style="color: #93a8c6;">]</span><span style="color: #8c8c8c;">}</span>
</pre>
</div>

<p>
Over time, we will send many newsletters, and our logbook will look like this:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">{</span><span style="color: #d08770;">:logbook</span> <span style="color: #93a8c6;">[</span><span style="color: #b0b1a3;">{</span><span style="color: #d08770;">:newsletter</span> timestamp<span style="color: #b0b1a3;">}</span>
           <span style="color: #b0b1a3;">{</span><span style="color: #d08770;">:newsletter</span> timestamp<span style="color: #b0b1a3;">}</span>
           <span style="color: #b0b1a3;">{</span><span style="color: #d08770;">:newsletter</span> timestamp<span style="color: #b0b1a3;">}</span><span style="color: #93a8c6;">]</span><span style="color: #8c8c8c;">}</span>
</pre>
</div>

<p>
A logbook is flexible because you can record all kinds of events that occured with regards to an entity. 
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">{</span><span style="color: #d08770;">:first-name</span> <span style="color: #a3be8c;">"Benjamin"</span>
 <span style="color: #d08770;">:last-name</span> <span style="color: #a3be8c;">"Peirce"</span>
 <span style="color: #d08770;">:occupation</span> <span style="color: #a3be8c;">"Mathematician"</span>
 <span style="color: #d08770;">:email</span> <span style="color: #a3be8c;">"benjamin.peirce@harvard.edu"</span>
 <span style="color: #d08770;">:logbook</span> <span style="color: #93a8c6;">[</span><span style="color: #b0b1a3;">{</span><span style="color: #d08770;">:welcome-email</span> timestamp<span style="color: #b0b1a3;">}</span>
           <span style="color: #b0b1a3;">{</span><span style="color: #d08770;">:subscription-reminder</span> timestamp<span style="color: #b0b1a3;">}</span>
           <span style="color: #b0b1a3;">{</span><span style="color: #d08770;">:subscription-reminder</span> timestamp<span style="color: #b0b1a3;">}</span>
           <span style="color: #b0b1a3;">{</span><span style="color: #d08770;">:newsletter</span> timestamp<span style="color: #b0b1a3;">}</span>
           <span style="color: #b0b1a3;">{</span><span style="color: #d08770;">:newsletter</span> timestamp<span style="color: #b0b1a3;">}</span>
           <span style="color: #b0b1a3;">{</span><span style="color: #d08770;">:newsletter</span> timestamp<span style="color: #b0b1a3;">}</span><span style="color: #93a8c6;">]</span><span style="color: #8c8c8c;">}</span>
</pre>
</div>

<p>
We can tell at first glance that we have sent our user a welcome email, two subscription reminders and three newsletters.
</p>

<p>
This is all the information we need to ensure idempotency when sending email to the user. We will see how in a moment, but the net outcome is that we can run <code>send-newsletter</code> multiple times, and still be sure that the newsletter gets sent only if it needs to be. 
</p>

<blockquote>
<p>
In computing, an idempotent operation is one that has no additional effect if it is called more than once with the same input parameters. 
In mathematics, an idempotent operation is one where <i>f</i> (<i>f</i> (x)) = <i>f</i> (x).
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #b48ead;">doseq</span> <span style="color: #93a8c6;">[</span>user users
        <span style="color: #d08770;">:when</span> <span style="color: #b0b1a3;">(</span>some <span style="color: #97b098;">(</span><span style="color: #b48ead;">fn</span> <span style="color: #aebed8;">[</span>entry<span style="color: #aebed8;">]</span> <span style="color: #aebed8;">(</span>is-timestamp-within-range <span style="color: #bf616a;">%</span><span style="color: #aebed8;">)</span><span style="color: #97b098;">)</span> <span style="color: #97b098;">(</span>filter <span style="color: #d08770;">:newsletter</span> <span style="color: #aebed8;">(</span><span style="color: #d08770;">:logbook</span> user<span style="color: #aebed8;">)</span><span style="color: #97b098;">)</span><span style="color: #b0b1a3;">)</span><span style="color: #93a8c6;">]</span>
  <span style="color: #93a8c6;">(</span>send-newsletter user<span style="color: #93a8c6;">)</span><span style="color: #8c8c8c;">)</span>
</pre>
</div>

<p>
We send our newsletters once a month, so the <code>is-timestamp-within-range</code> predicate checks if the recorded timestamp falls in that interval.
Our welcome email gets sent only once, so an idempotent <code>send-welcome-email</code> would look a little bit different:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #b48ead;">doseq</span> <span style="color: #93a8c6;">[</span>user users
        <span style="color: #d08770;">:when</span> <span style="color: #b0b1a3;">(</span>empty? <span style="color: #97b098;">(</span>filter <span style="color: #d08770;">:welcome-email</span> <span style="color: #aebed8;">(</span><span style="color: #d08770;">:logbook</span> user<span style="color: #aebed8;">)</span><span style="color: #97b098;">)</span><span style="color: #b0b1a3;">)</span><span style="color: #93a8c6;">]</span>
  <span style="color: #93a8c6;">(</span>send-welcome-email user<span style="color: #93a8c6;">)</span><span style="color: #8c8c8c;">)</span>
</pre>
</div>

<p>
In other words, we architecture our operations around events and predicates. 
In our example, the events are <code>:welcome-email</code>, <code>:subscription-reminder</code> and <code>:newsletter</code>. 
We can standardize our predicates and decide that they will operate on a logbook entry (if found):
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #b48ead;">defn</span> <span style="color: #8fa1b3;">unique?</span> #<span style="color: #93a8c6;">(</span>some? <span style="color: #bf616a;">%</span><span style="color: #93a8c6;">)</span>
<span style="color: #93a8c6;">(</span><span style="color: #b48ead;">defn</span> <span style="color: #8fa1b3;">last-month?</span> #<span style="color: #b0b1a3;">(</span><span style="color: #b48ead;">if-let</span> <span style="color: #97b098;">[</span>date <span style="color: #aebed8;">(</span>first <span style="color: #b0b0b3;">(</span>vals <span style="color: #bf616a;">%</span><span style="color: #b0b0b3;">)</span><span style="color: #aebed8;">)</span><span style="color: #97b098;">]</span>
                     <span style="color: #97b098;">(</span><span style="color: #c0c5ce;">time</span><span style="color: #c0c5ce; background-color: #2b303b;">/</span>last-month? date<span style="color: #97b098;">)</span>
                     <span style="color: #d08770;">false</span><span style="color: #b0b1a3;">)</span>
</pre>
</div>

<p>
This allows us to compose them neatly with logbook sequences.
</p>

<pre class="example">
(some unique? (filter :welcome-email (:logbook user)))
</pre>

<pre class="example">
(some last-month? (filter :newsletter (:logbook user)))
</pre>

<p>
Now let’s look back at our newsletter sending operation. 
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #b48ead;">doseq</span> <span style="color: #93a8c6;">[</span>user users
        <span style="color: #d08770;">:when</span> <span style="color: #b0b1a3;">(</span>some last-month? <span style="color: #97b098;">(</span>filter <span style="color: #d08770;">:newsletter</span> <span style="color: #aebed8;">(</span><span style="color: #d08770;">:logbook</span> user<span style="color: #aebed8;">)</span><span style="color: #97b098;">)</span><span style="color: #b0b1a3;">)</span><span style="color: #93a8c6;">]</span>
  <span style="color: #93a8c6;">(</span>send-newsletter user<span style="color: #93a8c6;">)</span><span style="color: #8c8c8c;">)</span>
</pre>
</div>

<p>
Something is missing, right?
If the newsletter is sent successfully, we need to write an entry in the logbook. 
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #b48ead;">doseq</span> <span style="color: #93a8c6;">[</span>user users
        <span style="color: #d08770;">:when</span> <span style="color: #b0b1a3;">(</span>some last-month? <span style="color: #97b098;">(</span>filter <span style="color: #d08770;">:newsletter</span> <span style="color: #aebed8;">(</span><span style="color: #d08770;">:logbook</span> user<span style="color: #aebed8;">)</span><span style="color: #97b098;">)</span><span style="color: #b0b1a3;">)</span><span style="color: #93a8c6;">]</span>
  <span style="color: #93a8c6;">(</span><span style="color: #b48ead;">let</span> <span style="color: #b0b1a3;">[</span>response <span style="color: #97b098;">(</span>send-newsletter user<span style="color: #97b098;">)</span><span style="color: #b0b1a3;">]</span>
    <span style="color: #b0b1a3;">(</span><span style="color: #b48ead;">when</span> <span style="color: #97b098;">(</span>success? response<span style="color: #97b098;">)</span>
      <span style="color: #97b098;">(</span>write-to-logbook user<span style="color: #97b098;">)</span><span style="color: #b0b1a3;">)</span><span style="color: #93a8c6;">)</span><span style="color: #8c8c8c;">)</span>
</pre>
</div>

<p>
If you have some experience writing web applications, you probably
recognize this pattern. In REST APIS, <code>put</code> and <code>delete</code> operations
have similar requirements revolv” around idempotency.
</p>

<p>
I call it the “Peirce pattern”, after the American mathematician who
coined the term “idempotency”. 
</p>

<blockquote>
<p>
Idempotent operations are often used in the design of network protocols, where a request to perform an operation is guaranteed to happen at least once, but might also happen more than once. If the operation is idempotent, then there is no harm in performing the operation two or more times.
</p>
</blockquote>


<p>
If you have read SICP, you may remember how we muster means of abstraction to generalize a problem. This allows us in turn to devise a solution for a whole class of related problems. What our solution lacks is generality. 
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #b48ead;">doseq</span> <span style="color: #93a8c6;">[</span>user users
        <span style="color: #d08770;">:when</span> <span style="color: #b0b1a3;">(</span>some last-month? <span style="color: #97b098;">(</span>filter <span style="color: #d08770;">:newsletter</span> <span style="color: #aebed8;">(</span><span style="color: #d08770;">:logbook</span> user<span style="color: #aebed8;">)</span><span style="color: #97b098;">)</span><span style="color: #b0b1a3;">)</span><span style="color: #93a8c6;">]</span>
  <span style="color: #93a8c6;">(</span><span style="color: #b48ead;">let</span> <span style="color: #b0b1a3;">[</span>response <span style="color: #97b098;">(</span>send-newsletter user<span style="color: #97b098;">)</span><span style="color: #b0b1a3;">]</span>
    <span style="color: #b0b1a3;">(</span><span style="color: #b48ead;">when</span> <span style="color: #97b098;">(</span>success? response<span style="color: #97b098;">)</span>
      <span style="color: #97b098;">(</span>write-to-logbook user<span style="color: #97b098;">)</span><span style="color: #b0b1a3;">)</span><span style="color: #93a8c6;">)</span><span style="color: #8c8c8c;">)</span>
</pre>
</div>

<p>
This ad-hoc snippet really boils down to:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #b48ead;">doseq</span> <span style="color: #93a8c6;">[</span>entity entities
        <span style="color: #d08770;">:when</span> <span style="color: #b0b1a3;">(</span>some pred logbook<span style="color: #b0b1a3;">)</span><span style="color: #93a8c6;">]</span>
  <span style="color: #93a8c6;">(</span><span style="color: #b48ead;">let</span> <span style="color: #b0b1a3;">[</span>response <span style="color: #97b098;">(</span>operation entity<span style="color: #97b098;">)</span><span style="color: #b0b1a3;">](</span>pn-get-property <span style="color: #d08770;">:base-directory</span><span style="color: #b0b1a3;">)</span>
    <span style="color: #b0b1a3;">(</span><span style="color: #b48ead;">when</span> <span style="color: #97b098;">(</span>success? response<span style="color: #97b098;">)</span>
      <span style="color: #97b098;">(</span>persist entity<span style="color: #97b098;">)</span><span style="color: #b0b1a3;">)</span><span style="color: #93a8c6;">)</span><span style="color: #8c8c8c;">)</span>
</pre>
</div>

<p>
With proper design and the magic of macros, we can actually write the following:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #b48ead;">doseq</span> <span style="color: #93a8c6;">[</span>entity entities<span style="color: #93a8c6;">]</span>
  <span style="color: #93a8c6;">(</span>with-logbook entity event
    <span style="color: #b0b1a3;">(</span>operation entity<span style="color: #b0b1a3;">)</span><span style="color: #93a8c6;">)</span><span style="color: #8c8c8c;">)</span>
</pre>
</div>

<p>
The entity (<code>user</code>), the operation (<code>send-newsletter</code>) and the event
(the choice of predicate) have been abstracted. 
</p>

<p>
All the rest has been made implicit: how we retrieve the logbook for an entity, how we determine if the operation was successful, how we
append events to the logbook. Instead of cluttering the calling site, the user makes those assumptions explicit via a configuration mechanism. From then on, the <code>with-logbook</code> macro will do the reshuffle and the wiring behind the scenes. 
</p>

<p>
This is the value proposal of Benjamin, which I’m open sourcing today. Actual production code looks like this: 
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #b48ead;">defn</span> <span style="color: #8fa1b3;">send-subscribed</span> <span style="color: #93a8c6;">[</span>user<span style="color: #93a8c6;">]</span>
  <span style="color: #93a8c6;">(</span><span style="color: #b48ead;">let</span> <span style="color: #b0b1a3;">[</span>to <span style="color: #97b098;">(</span><span style="color: #d08770;">:email</span> user<span style="color: #97b098;">)</span>
        subject <span style="color: #a3be8c;">"You have been successfully subscribed"</span>
        body template<span style="color: #b0b1a3;">]</span>
    <span style="color: #b0b1a3;">(</span>with-logbook user <span style="color: #d08770;">:subscribed</span>
      <span style="color: #97b098;">(</span>email to subject body<span style="color: #97b098;">)</span><span style="color: #b0b1a3;">)</span><span style="color: #93a8c6;">)</span><span style="color: #8c8c8c;">)</span>
</pre>
</div>

<p>
This syntactic goodness comes at the cost of dynamic scoping, but the present use case doesn’t lay out the perils typical of resource management, for example. Sure, the configuration is implicit, but it is set once for the lifetime of the application and needn’t change. Still, it is a hack, and rather Lispy at that, relying on features Clojurians would normally eschew, macros and dynamic scope. It not guaranteed to fit all use cases, but chances are it will some. I see it as a tiny library that packs a punch, and I for one am embracing it.  
</p>

<p>
Check it out on github.
</p>
