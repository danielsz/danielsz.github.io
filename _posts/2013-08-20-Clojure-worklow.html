---
title: Clojure worklow
layout: post
tags: clojure workflow reloaded stuart_sierra repl
---



<p>
The REPL is a cornerstone in the Lisp experience. It is a venerable, time-tested way to do interactive development, enabling the developer to modify a running system with (near) zero latency. 
</p>
<p>
One could argue that debuggers enable the same thing, or worse, one could have been led to believe that the the <i>I</i> in <a href="http://en.wikipedia.org/wiki/Integrated_development_environment">IDE</a> stands for <i>interactive</i>, but that would not do justice to REPL-based development, which embodies the idea behind Sherry Turkle's /<a href="http://en.wikipedia.org/wiki/Bricolage#Information_technology">Bricolage</a>/ style of programming for bottom-up programming (incremental development). The REPL provides unparalleled hackability, discoverability and testability. Because you have access to all aspects of the system, the REPL eliminates the need for mocking or special purpose testing libraries.  As Andy Wingo once put it, it puts the user in the [Read Eval Print] Loop.
It is very hard to design a language with a good story for interactive programming. Lisp-based languages lend themselves notoriously well to this, though. If you've dabbled with a REPL provided by a non-Lisp language, (such as Ruby's IRB), you might be interested to watch how far it can be pushed, 
The REPL enables various things: 
</p>
<ul>
<li>live coding (music and shows)
</li>
<li>incremental development, also known as bottom-up programming.
</li>
<li>debugging and testing
</li>
</ul>


<p>
<a href="http://www.papert.org/articles/EpistemologicalPluralism.html">Epistemological Pluralism and the Revaluation of the Concrete</a>, by Seymour Papert and Sherry Turkle
</p>


<div id="outline-container-1" class="outline-3 bnote">
<h3 id="sec-1">Examples of REPL-based development</h3>
<div class="outline-text-3" id="text-1">


<p>
It is instructive to see how REPL-based development works. 
</p>
<p> 
<a href="http://www.youtube.com/watch?v=P9tfxdcpkCc">REPL-Based Development with Immutant</a> by Jim Crossley.
<a href="https://www.youtube.com/watch?v=imoWGsipe4k">Programming Music with Overtone - Sam Aaron</a>
</p>
<p>
The art of REPL-based development has been pushed to its utter limit in the SLIME environment. <a href="http://www.youtube.com/watch?v=_B_4vhsmRRI"> Marco Baringer's SLIME Tutorial Video</a>. 
</p>
</div>

</div>

<div id="outline-container-2" class="outline-3">
<h3 id="sec-2"></h3>
<div class="outline-text-3" id="text-2">



<p>
The Clojure community has embraced the REPL since day one, but this is not to say that poblems are inexistent. 
</p>
<p>
The following technique is more akin to live reload, , Instant Reload. code reloading
Instead of executing code in the REPL, source files are edited, and then reloaded. 
</p>
<p>
, which is a Lisp, 
</p>
<p>
. Suffice to say that REPL-based development 
</p>
<p>
REPL-driven development is one of those things harder to explain than to demonstrate, or from a user's perspective, harder to tackle conceptually than to experience. Fortunately, all you need is firing up a REPL and 
</p>
<p>
you just need to experience. 
</p>
<p>
If the IDE is an acronym for Interactive Development Environment, wait until you experience the REPL. you spell One might be tempted to think that the "I" in IDE stands for interactive development environment, 
  pro
Absent from the traditional  mainstream IDEs, 
development environments,
</p>
<p>
Despite its name, the IDE,  
Not every developer had the luxury to body knows it, simply because it is not universally available. The model of 
</p>
<p>
 Methodology, One Needs Explain Himself, Because It 
</p>
<p>
the REPL experience, it needs to be explained, because 
</p>
<p>
can be modified inwithout being restarted.  It is an experience that many don't know, simply because it is not mainstream. 
</p>
<p>
eliminating the latency between code modification and  coding,  oldest form of interactive development, of the same kind that Bret Victor is calling 
 venerable version 
</p>
<p>
Like any experience, it is difficult to grasp unless you've tried it for yourself. 
exp, but if we were to do it, or as Andy Wingo puts it, it puts the user in the loop. 
</p>
<p>
What's better than evaluating a function definition and seeing it 
</p>
<p>
 Nothing beats the live coding experience, 
</p>
<p>
If you've had a taste of REPL-driven development before and you've come to Clojure with the expectations 
to find the same experience that other environments may have provided, you might find bump in some 
</p>
<p>
I won't be as bold to name it a design pattern, but a practice in the Clojure community has emerged regarding how to structure an application so as to benefit from REPL-based development despite . 
</p>
<p>
in how to best structure an application. 
 to get 
</p>
<p>
This blog post builds on the work of Stuart Sierra and colleagues from Relevance, who devised a workflow when building systems that need to run in multiple contexts. The typical scenario is a system that will behave differently depending on whether it is running in production mode, development mode or testing mode. Configuration for the components used in the system might not be the same, and sometimes the components themselves are not the same (in-memory database for development, persistence in production code). 
For various reasons better explained elsewhere, reevaluating code in the repl is not sufficient, and something more robust might be required.
</p>
<ul>
<li>Blog post: <a href="http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded">My Clojure Workflow, Reloaded</a>
</li>
<li>Podcast:  <a href="http://thinkrelevance.com/blog/2013/05/29/stuart-sierra-episode-032">Stuart Sierra - Episode 032</a>
</li>
<li>Video: <a href="http://www.infoq.com/presentations/Clojure-Large-scale-patterns-techniques">Clojure in the Large</a>
</li>
<li>Github project: <a href="https://github.com/candera/aws-stats">candera/aws-stats</a>
</li>
<li>Github project: <a href="https://github.com/mybuddymichael/pgbot">mybuddymichael/pgbot</a>
</li>
</ul>


<p>
Let's demonstrate Stuart Sierra's technique in an orderly manner. We will start with the most minimal set of files and code to showcase the workflow, then we'll expand on it and see how we can achieve a more realistic scenario. We want to keep in mind that the objective is to have a system that can be easily poked interactively at the REPL, easy to test, and easy to deploy.
</p>
<p>
Concepts: 
</p><ul>
<li>Vars and dynamic binding (alter-var-root). Joy of Clojure p.270
</li>
</ul>


<p>
First, we can leverage the leiningen template that Stuart has made available on clojars.org.
</p>



<pre class="src src-bash">$ lein new reloaded com.example/new-project
</pre>


<p>
This will result in the following directory tree.
</p>



<pre class="src src-bash">|___README.md
|___dev
| |___user.clj
|___epl-v10.html
|___project.clj
|___src
| |___com
| | |___example
| | | |___core.clj
</pre>


<p>
We need to concern ourselves only with user.clj, core.clj and project.clj. 
We are going to build a minimal ring application with just one endpoint.  
</p>


<script type="text/javascript" src="http://ascii.io/a/5010.js" id="asciicast-5010" async></script>

<p>
So now we can start to examine how.
The minimalistic example is a map with keywords denoting the components. 
We can now type (go) at the repl, make changes in the code, then type (reset), upon which our code gets reloaded, and the components restarted. 
With this minimalist example, if you type <code>lein uberjar</code>, you have a deployed application.
Note that we have no production system yet, nor do we have any lifecycle management.
</p>
<p>
In order to understand the following section, you need to understand the following language constructs:
</p>
<p>
Concepts:
</p>
<ul>
<li>records (datatype) Joy of Clojure p.189 
</li>
<li>protocols (polymorphism construct) Joy of Clojure p.192
</li>
<li>destructuring (bind locals based on an expected form of composites) Joy of Clojure p.47
</li>
</ul>


<p>
In Clojure, protocols are a polymorphism construct, and can be used here to define the component interface. By adhering to the protocol, every component will have a start and a stop function. Whether we add a web server or a database or anyhting else, we'll start by "componentize" it. And this only means to abstract it away in a record that exend the protocol. 
</p>
<p>
Here is how the protocol looks like:
</p>



<pre class="src src-clojure">(<span style="color: #A52A2A; font-weight: bold;">defprotocol</span> <span style="color: #00578E; font-weight: bold;">Lifecycle</span>
  (start [component]
    <span style="color: #4E9A06;">"Runs side effects to start the component. Returns the component."</span>)
  (stop [component]
    <span style="color: #4E9A06;">"Runs side effects to stop the component. Returns the component."</span>))

</pre>


<p>
We are going to define a function that returns an instance of the component. 
</p>
<p>
 by making it  Ading that we add to our application will having a
</p>
<p>
 by our components. By extending the 
pClojure
So let's define a protocol that our components will need to implement, a unique interface with a start and a stop function. Everytime we add a component, we create a record that extends the lifestyle protocol, and a convenience function that returns an instance of said component in a stopped state. We then add the component to the subcomponents key of our application, and so we can start all components in one broad sweep.
</p>
<p>
Let's show this with a web server.
</p>
<p>
A couple of notes. 
</p>
</div>

</div>

<div id="outline-container-3" class="outline-3 bnote">
<h3 id="sec-3">Note for OOP programmers</h3>
<div class="outline-text-3" id="text-3">


<p>
The only storage in our program is the system Var, and that is only present in the user namespace in development mode. When you run the application in production, no such storage exist. 
Every other function returns a value, or runs side effects on their input.
</p>
<p>
<code>application/create</code> returns a vector with our components. <code>application/start</code> and <code>application/stop</code> run side effects on their input, a vector of components. 
</p>
</div>

</div>

<div id="outline-container-4" class="outline-3 anote">
<h3 id="sec-4">Note for functional programmers</h3>
<div class="outline-text-3" id="text-4">


<p>
 In a next iteration, we might want to replace the vector with a map, where each component would have a key associated with it. This is what <a href="https://github.com/mybuddymichael/pgbot">mybuddymichael/pgbot</a> does.
</p>
<p> 
Sure, <code>-main</code> calls application.
</p>
</div>

</div>

<div id="outline-container-5" class="outline-3">
<h3 id="sec-5">How to add a component?</h3>
<div class="outline-text-3" id="text-5">


<p>
1 Write the record and function returning an instance of it (in a stopped state).
2 Write the protocol implementation
3 In application/create, create the component. 
</p>
</div>

</div>

<div id="outline-container-6" class="outline-3">
<h3 id="sec-6">How to reload in development?</h3>
<div class="outline-text-3" id="text-6">

</div>

</div>

<div id="outline-container-7" class="outline-3">
<h3 id="sec-7">How to deploy?</h3>
<div class="outline-text-3" id="text-7">

</div>

</div>

<div id="outline-container-8" class="outline-3">
<h3 id="sec-8">How to test?</h3>
<div class="outline-text-3" id="text-8">

<p>Outside of the repl, you can run <code>lein test</code>. Of course, that is slow. In the repl, you can type <code>(test/run-all-tests)</code> and your tests will run. But you probably want to restrict your tests to the user tests, so run <code>(test/run-tests 'com.example.handler-test)</code>. If you're using Emacs, you can type <code>C-c C-(,)</code> to run your tests, provided you've installed <b>clojure-test-mode</b>.
</p>
<p>  
You might want to define a keyboard shortcut to that, too.
We shouldn't forget to reload our code, so this will do the trick
</p>
<p>
<a href="https://www.youtube.com/watch?feature=player_embedded&amp;v=iazvlNYjtaM">Live coding the FizzBuzz test in Clojure</a>
</p>



<pre class="src src-emacs-lisp">(<span style="color: #A52A2A; font-weight: bold;">defun</span> <span style="color: #00578E; font-weight: bold;">nrepl-tests</span> ()
  (interactive)
  (nrepl-interactive-eval <span style="color: #4E9A06;">"(test/run-tests 'com.example.handler-test)"</span>))

</pre>

</div>

</div>

<div id="outline-container-9" class="outline-3">
<h3 id="sec-9">Emacs goodies</h3>
<div class="outline-text-3" id="text-9">


<p>
I was experimenting with integrated tools.namespace reloading in elisp as well, and I found a slightly nicer way to send commands to nrepl:
</p>
<p>
the output in the minibuffer, 
</p>



<pre class="src src-emacs-lisp">(<span style="color: #A52A2A; font-weight: bold;">defun</span> <span style="color: #00578E; font-weight: bold;">nrepl-reset</span> ()
  (interactive)
  (nrepl-interactive-eval <span style="color: #4E9A06;">"(user/reset)"</span>))

</pre>


<p>
the latter will display it in the repl.
</p>



<pre class="src src-emacs-lisp">(<span style="color: #A52A2A; font-weight: bold;">defun</span> <span style="color: #00578E; font-weight: bold;">nrepl-reset</span> ()
  (interactive)
  (set-buffer <span style="color: #4E9A06;">"*nrepl*"</span>)
  (goto-char (point-max))
  (insert <span style="color: #4E9A06;">"(user/reset)"</span>)
  (nrepl-return))

</pre>



</div>
</div>
