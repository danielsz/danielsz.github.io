---
permalink: /towards-a-declarative-dependency-management-s/index.html
layout: post
title: Towards a declarative dependency management solution for Emacs
published: true
categories: []
---
<p class="p1">If you're an Emacs user, you probably have customized your editor to your liking. You may also have devised a way to make your configuration portable. Naturally, you want to be able to use Emacs on any computer where works needs to be done, and you want everywhere the same bespoke experience. The ways to achieve that portability are varied. Over time, I have experimented with different approaches that I believe reflect the natural evolution of any Emacs user, that is to say a shift from unsophisticated techniques to more refined ones.&nbsp;I would like to start off summarizing those approaches.&nbsp;</p>
<p class="p1">First, there's the manual approach. Often, novice users don't know better. In this scenario, duplicating an Emacs setup involves copying your config file to the new computer, examining the extensions that you will need to install manually, or simply watching the errors popping up as a result of unmet dependencies. Then you go to the slow process of reinstalling them one by one.&nbsp;</p>
<p class="p1">Sooner or later, you realize that there must be a better way. When&nbsp;you start asking around, people will likely tell you to put <em>.emacs.d</em> under version control. This way, both your <em>.init.el</em> and your extensions are available anytime at the press of a <em>git pull</em> command (or equivalent). This is a valid approach adopted by many advanced Emacs users. It always bothered me for two reasons. One is that I have to put shared code under version control. I'd avoid that if I could help it. In modern programming environments, after all, you put your own code under version control. The dependencies, on the other hand, are formally declared in a file, and a native facility allows you to pull those dependencies when time comes to duplicate your project elsewhere (at deploy time, for example). In Ruby, that native facility is called <em>bundler</em>, Java users might be familiar with <em>maven</em>, and the list goes on. The second thing that bothers me with this approach is that when dependencies are themselves pulled from repositories, you suddenly have to deal with submodules, which complicate matters further.</p>
<p class="p1">What I really wanted was to put the config file, and only that, under version control. Somehow, the dependencies would be pulled automatically. With the advent of the Emacs Lisp Package Archive (ELPA), this became a possibility. No more manual downloading of packages, copying them to the right place, adding specific initialization code in the config file. ELPA would take care of all this. You could write code in your config file that ensured the presence of packages, and have them installed automatically if they were missing:&nbsp;</p>
<p class="p1"><span class="s1"><a href="https://gist.github.com/3825823.js?file=canonical_package.el"><span class="s2"><script src="https://gist.github.com/3825823.js?file=canonical_package.el"></script></span></a></span></p>
<p class="p1"><span class="s1"> </span></p>
<p class="p1">ELPA was a huge progress in Emacsland. Still, it wasn't perfect. See Bozhidar Batsov's <a href="http://batsov.com/articles/2012/02/19/package-management-in-emacs-the-good-the-bad-and-the-ugly/" title="Package Management in Emacs: The Good, the Bad and the Ugly" target="_blank">post</a> for a good discussion around ELPA. And unless you had <em>.emacs.d</em> under version control, ELPA still fell short of providing all the pieces needed to make your configuration truly portable. When you were uninstalling a package on one machine, you would have to replicate that action on all the other machines. What was missing is a cleanup function, elisp code that would uninstall packages as soon as they were dereferenced from the canonical list. My quest for a fully portable declarative dependency management solution for Emacs was not over.</p>
<p class="p1">I started with posting a <a href="http://stackoverflow.com/questions/12552877/el-get-in-a-portable-emacs-configuration-solution" title="Question on Stack Overflow" target="_blank">question</a> on stack overflow. I wanted to make sure I was not missing anything. Maybe somebody had already written such code. The answer, unsurprisingly, was to put <em>.emacs.d</em> under version control. A valid answer, but not what I was looking for. So I opened an issue on github for the <em>el-get</em> project.&nbsp;</p>
<p class="p1">Why <em>el-get</em>?&nbsp;</p>
<p class="p1"><em>package.el</em> (which started in a package called ELPA and was later merged in Emacs 24) understand the package <a href="http://marmalade-repo.org/doc-files/package.5.html" title="Marmalade package format" target="_blank">format</a>, which implies that extension authors or maintainers need to package their elisp code. This is reasonable, but the reality is that many Emacs extensions come as a single elisp file on EmacsWiki, or are hosted on privately hosted pages, or are available behind systems like <em>bazaar</em>, <em>git</em> and others. <em>el-get</em> is an interface that abstracts away the chaos, and plays nicely along ELPA to boot. &nbsp;</p>
<p class="p1">Soon enough, I got a reply from the maintainer that no, he didn't have a cleanup feature, but that he was open to the idea. Would I write it? And so, with Dimitri Fontaine's&nbsp;invaluable assistance, I published a pull request enabling the cleanup feature. This concluded my search for a comprehensive, declarative dependency management solution for Emacs. The previous code could be replaced by a simple <em>el-get 'sync</em>. Now I could write:</p>
<p class="p3"><span class="s2"><a href="https://gist.github.com/3825823.js?file=canonical_el-get.el"><span class="s3"><script src="https://gist.github.com/3825823.js?file=canonical_el-get.el"></script></span></a></span></p>
<p class="p1">The cleanup functionality is integrated in <em>el-get</em>'s master branch, which is installed like so:</p>
<p class="p3"><span class="s2"><a href="https://gist.github.com/3825823.js?file=install_el-get_in_scratch.el"><span class="s3"><script src="https://gist.github.com/3825823.js?file=install_el-get_in_scratch.el"></script></span></a></span></p>
<p class="p1">So, now you have the ability to declare your Emacs extensions in your <em>.init.el</em>, and version control only that. To make <em>git</em> ignore all files except the config file, you'll instruct <em>.gitignore</em> in the following manner:</p>
<p class="p3"><span class="s2"><span class="s3"><script src="https://gist.github.com/3825823.js?file=gistfile1.txt"></script></span></span></p>
<p class="p3">And oh, happy Emacsing!</p>
